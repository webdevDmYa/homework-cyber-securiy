# homework_vulnerability_scanner.py
# Імпортуємо (підключаємо) необхідні модулі - це готові інструменти Python
import subprocess  # Дозволяє запускати системні команди (як в командному рядку)
import platform    # Дає інформацію про операційну систему
import sys         # Для роботи з системними функціями (вихід з програми, помилки)
from typing import Optional  # Для підказок типів даних (необов'язково, але корисно)
import csv
import requests # - бібліотека для роботи з інтернетом (HTTP запити)
import time

def get_windows_apps() -> list[str]:
    """
    Отримує список програм на Windows через PowerShell.

    Що робить функція:
    1. Запускає команду PowerShell для читання реєстру Windows
    2. Шукає інформацію про встановлені програми в двох місцях реєстру
    3. Повертає відсортований список назв програм
    """
    # Створюємо команду для PowerShell (це як "мова" Windows)
    # Команда йде в реєстр (база даних Windows) і шукає встановлені програми
    command = [
        "powershell", "-Command",  # Говоримо, що це команда PowerShell
        "Get-ItemProperty HKLM:\\Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*, "
        "HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* | "
        "Select-Object DisplayName | Where-Object { $_.DisplayName } | "
        "Sort-Object DisplayName | ForEach-Object { $_.DisplayName }"
    ]

    # subprocess.run() - запускає команду і чекає результату
    result = subprocess.run(
        command,
        capture_output=True,  # Зберігаємо результат команди
        text=True,            # Результат як текст (не байти)
        encoding="utf-8",     # Кодування тексту (щоб підтримувати українські букви)
        errors="ignore"       # Ігноруємо помилки кодування
    )

    # Перевіряємо, чи команда виконалась успішно
    # returncode == 0 означає "все добре", інше число = помилка
    if result.returncode != 0:
        raise RuntimeError(f"PowerShell error: {result.stderr}")

    # Обробляємо результат:
    # 1. result.stdout - текст, який повернула команда
    # 2. .split("\n") - ділимо на окремі рядки
    # 3. line.strip() - прибираємо пробіли на початку і кінці
    # 4. if line.strip() - беремо тільки непорожні рядки
    apps = [line.strip() for line in result.stdout.strip().split("\n") if line.strip()]

    # sorted(set(apps)) - прибираємо дублікати (set) і сортуємо по алфавіту (sorted)
    return sorted(set(apps))


def get_macos_apps() -> list[str]:
    """
    Отримує список .app програм на macOS.

    Що робить функція:
    1. Шукає всі файли з розширенням .app у папці Applications
    2. Витягує назви програм з повних шляхів
    3. Повертає відсортований список назв
    """
    # Команда find шукає файли (як пошук у Finder на Mac)
    # /Applications - папка де зберігаються програми на Mac
    # -maxdepth 2 - шукаємо не глибше ніж на 2 рівні вкладеності
    # -name '*.app' - шукаємо тільки файли що закінчуються на .app
    # -type d - шукаємо директорії (на Mac програми це теж папки)
    # 2>/dev/null - ховаємо повідомлення про помилки
    command = "find /Applications -maxdepth 2 -name '*.app' -type d 2>/dev/null"

    # Запускаємо команду через термінал
    result = subprocess.run(
        command,
        shell=True,           # Виконуємо як команду терміналу
        capture_output=True,  # Зберігаємо результат
        text=True             # Результат як текст
    )

    # Створюємо порожній список для зберігання назв програм
    apps = []

    # Проходимо по кожному рядку результату (кожен рядок = шлях до програми)
    for path in result.stdout.strip().split("\n"):
        if path:  # Якщо рядок не порожній
            # Приклад: "/Applications/Safari.app" -> "Safari"
            # path.split("/") - ділимо шлях на частини: ["", "Applications", "Safari.app"]
            # [-1] - беремо останній елемент: "Safari.app"
            # .replace(".app", "") - прибираємо ".app": "Safari"
            app_name = path.split("/")[-1].replace(".app", "")
            apps.append(app_name)  # Додаємо назву до списку

    # Прибираємо дублікати та сортуємо
    return sorted(set(apps))


def get_linux_apps() -> list[str]:
    """
    Отримує список пакетів на Linux (Debian/Ubuntu або Fedora/RedHat).

    Що робить функція:
    1. Спочатку пробує команду для Ubuntu/Debian (dpkg-query)
    2. Якщо не вдається, пробує команду для Fedora/RedHat (rpm)
    3. Повертає відсортований список пакетів
    """
    # dpkg-query - інструмент для Debian/Ubuntu систем
    # -W - показати встановлені пакети
    # -f=${Package}\n - формат виводу (тільки назва пакету)
    command = ["dpkg-query", "-W", "-f=${Package}\n"]

    try:
        # Спробуємо запустити команду для Ubuntu/Debian
        result = subprocess.run(
            command,
            capture_output=True,  # Зберігаємо результат
            text=True,            # Результат як текст
            check=True            # Якщо помилка - викинути виняток
        )
        # Обробляємо результат: розділяємо на рядки і прибираємо пробіли
        apps = [line.strip() for line in result.stdout.strip().split("\n") if line.strip()]
        return sorted(apps)
    except FileNotFoundError:
        # FileNotFoundError означає, що dpkg-query не знайдено
        # Це значить що це не Debian/Ubuntu, а можливо Fedora/RedHat

        # rpm - інструмент для RedHat/Fedora систем
        # -qa - показати всі встановлені пакети
        # --qf "%{NAME}\n" - формат виводу (тільки назва)
        command = ["rpm", "-qa", "--qf", "%{NAME}\n"]
        result = subprocess.run(command, capture_output=True, text=True)
        apps = [line.strip() for line in result.stdout.strip().split("\n") if line.strip()]
        return sorted(apps)


def get_installed_apps() -> Optional[list[str]]:
    """
    Визначає операційну систему та повертає список програм.

    Що робить функція:
    1. Дізнається яка у вас ОС (Windows, Mac чи Linux)
    2. Викликає відповідну функцію для цієї ОС
    3. Повертає список програм
    """
    # platform.system() повертає назву ОС: "Windows", "Darwin" (Mac) або "Linux"
    system = platform.system()

    # Перевіряємо яка ОС і викликаємо відповідну функцію
    if system == "Windows":
        return get_windows_apps()
    elif system == "Darwin":  # macOS називається "Darwin" всередині системи
        return get_macos_apps()
    elif system == "Linux":
        return get_linux_apps()
    else:
        # Якщо ОС незнайома - виводимо помилку
        raise OSError(f"Непідтримувана ОС: {system}")

def search_vulnerabilities(keyword: str, limit: int = 5) -> dict:
    """
    Пошук вразливостей у NVD за ключовим словом.

    Що робить:
    1. Надсилає запит до NVD API (сервер у інтернеті)
    2. Отримує дані про вразливості у форматі JSON
    3. Повертає ці дані для подальшої обробки

    Параметри (що передаємо функції):
        keyword: Назва програми для пошуку (наприклад, "OpenSSH")
        limit: Скільки максимум результатів хочемо отримати

    Що повертає:
        Словник (dict) з даними про вразливості у форматі JSON
    """
    # URL - адреса API сервера NVD в інтернеті
    url = "https://services.nvd.nist.gov/rest/json/cves/2.0"

    # params - параметри запиту (що ми хочемо знайти)
    # Це як форма пошуку на веб-сайті

    params = {

        "keywordSearch": keyword,           # Що шукаємо
        "resultsPerPage": str(limit)        # Скільки результатів на сторінці
    }

    # headers - додаткова інформація про наш запит
    # User-Agent - "ім'я" нашої програми (щоб сервер знав хто запитує)
    headers = {
        "User-Agent": "Mozilla/5.0 (compatible; SecurityScanner/1.0)"
    }

    # requests.get() - надсилаємо GET запит (запитуємо дані)
    # timeout=30 - якщо сервер не відповість за 30 секунд, вважаємо що помилка
    response = requests.get(url, params=params, headers=headers, timeout=30)

    # raise_for_status() - якщо сервер повернув помилку (404, 500 і т.д.) - викинути виняток
    response.raise_for_status()

    # .json() - перетворює відповідь сервера у словник Python
    return response.json()


def main():

    OS_app = get_installed_apps()

    result = [] # Масив данних для файлу CSV

    for app in OS_app[:5]:

        print(f"Пошук вразливостей для {app}...")

        try:
         # Шукаємо вразливості для програм
            # TODO: Викличте search_vulnerabilities()

            data = search_vulnerabilities(app,5)
            print("-" * 50)  # Лінія-роздільник

         # Проходимо по всіх знайдених вразливостях
         # .get("vulnerabilities", []) - отримати список вразливостей
         # якщо його немає - повернути порожній список []

            data = data.get("vulnerabilities", [])

            for item in data:
                metrics = item["cve"].get("metrics", {})
                cvss_v2 = metrics.get("cvssMetricV2")
                if not cvss_v2:
                    continue

                score = cvss_v2[0]["cvssData"]["baseScore"]
                #score = item['cve']['metrics']['cvssMetricV2'][0]['cvssData']['baseScore']

                if score >= 8.0:
                    cve = item.get("cve", {})
                    cve_id = cve.get("id", "N/A")
                    descriptions = cve.get("descriptions", "N/A")
                    description = descriptions[0]['value']

                    print(f"\n{cve_id}")
                    print(f"  {description}...")  # [:100] - перші 100 символів

                    result.append({
                       "App": app,
                       "CVE": cve_id,
                       "Score": score or "N/A",
                       "Description": description
                    })
            # TODO: Збережіть all_results у CSV
            fieldnames = ["App", "CVE", "Score","Description"]
            with open("target_CVE.csv", "w", newline="", encoding="utf-8") as f:
            # csv.DictWriter - інструмент для запису словників у CSV
                writer = csv.DictWriter(f, fieldnames=fieldnames)
                writer.writeheader()    # Записуємо рядок з назвами колонок
                writer.writerows(result)  # Записуємо всі рядки даних

            # Витягуємо інформацію про CVE (вразливість)
            # cve = item.get("cve", {})
            # cve_id = cve.get("id", "N/A")  # ID вразливості (наприклад, CVE-2023-1234)

            # Отримуємо опис англійською мовою
            # descriptions = cve.get("descriptions", [])
            # next() - знаходить перший опис англійською
            # якщо не знайдено - повертає "No description"
            # description = next(
            #    (d["value"] for d in descriptions if d.get("lang") == "en"),
            #   "No description"

            # Виводимо ID та перші 100 символів опису
            # print(f"\n{cve_id}")
            # print(f"  {description[:100]}...")  # [:100] - перші 100 символів

    # Обробка помилок (якщо щось пішло не так)
        except requests.exceptions.HTTPError as err:
            # HTTPError - помилка від сервера (404, 500 і т.д.)
            print(f"HTTP помилка: {err}")
        except requests.exceptions.Timeout:
        # Timeout - сервер не відповів вчасно
            print("Помилка: перевищено час очікування запиту")
        except requests.exceptions.RequestException as err:
        # RequestException - будь-яка інша помилка з'єднання
            print(f"Помилка з'єднання: {err}")
        # TODO: Додайте time.sleep(6) між запитами
        time.sleep(6)

# Запускаємо програму
if __name__ == "__main__":
    main()
